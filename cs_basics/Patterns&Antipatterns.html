<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<title>Programming Patterns and Anti-Patterns</title>

		<link rel="stylesheet" href="../dist/reset.css">
		<link rel="stylesheet" href="../dist/reveal.css">
		<link rel="stylesheet" href="../dist/theme/black.css">

        <!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="../plugin/highlight/monokai.css">
		<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css">

		<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>

		<!-- and it's easy to individually load additional languages -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/go.min.js"></script>

		<link rel="stylesheet" href="https://pyscript.net/latest/pyscript.css" />
		<script>
			import hljs from "highlight.js";

			hljs.highlightAll();
		</script>
		<style>
			.column {
			  float: left;
			  width: 48%;
			  padding: 2px;
			}
			/* Clear floats after image containers */
			.row::after {
			  content: "";
			  clear: both;
			  display: table;
			}
			.important {
				color: orange;
			}
			.hierarchy-box { padding: 10px; border-radius: 4px; text-align: center; }
			.parent { background-color: #aaa; }
			.child { background-color: #ccc; display: inline-block; margin: 5px; }
			.special { background-color: #f88; }
		</style>
</head>
	<body onload="totalWrapper();">
		<div class="reveal">
			<div class="slides">
			<section>
				<div>
					<img src="images/nup_logo_dark.jpeg" alt="nup_logo" />
				</div>
				<h2>Programming Paradigms</h2>
				<h3>Programming Patterns and Anti-Patterns</h3>
				<br />
				Alex Avdiushenko <br />
				April 23, 2024
			</section>
			<section>
				<section>
					<h3 style="text-align: left">Evolution of Design Patterns</h3>
						<div class="typesetting">
							<ul>
								<li class="fragment"><strong class="important">Early Days (Before 1990s):</strong>
									Reuse of code snippets and solutions without a standardized methodology</li>
								<li class="fragment"><strong class="important">The Gang of Four (1994):</strong>
									Formal introduction of design patterns by Erich Gamma, Richard Helm, Ralph Johnson,
									and John Vlissides. Their book laid the groundwork for object-oriented design patterns</li>
								<li class="fragment"><strong class="important">Pattern Languages (Late 1990s):</strong>
									The concept of pattern languages emerged, emphasizing the relationships
									between patterns within a system</li>
							</ul>
						</div>
				</section>
				<section>
					<ul>
						<li><strong class="important">
							Rise of Software Frameworks and Libraries (2000s):</strong>
							Frameworks and libraries encapsulated design patterns,
							making them more accessible and integral to software development</li>
						<li class="fragment"><strong class="important">
							Advent of Microservices and Cloud Computing (2010s):</strong>
							New patterns developed to address the complexities of distributed systems,
							focusing on scalability, resilience, and inter-service communication</li>
						<li class="fragment"><strong class="important">Current Trends and Future Directions:</strong>
							Design patterns evolve with advancements in AI, machine learning, IoT,
							emphasizing adaptability, modularity,
							and interoperability for complex data flows and system integration</li>
					</ul>
				</section>
				<section data-background-color="white">
					<img src="images/airplane_blueprint.jpg" alt="airplane_blueprint" width="70%">
				</section>
				<section data-background-color="white">
					<img src="images/molds.jpg" alt="molds" width="70%">
				</section>
				<section>
					<h3 style="text-align: left">Real-world Analogy: Design Patterns</h3>
					<div class="fragment">
						<div class="typesetting">
							<p style="text-align: left">Design patterns in software are akin
								to templates used in construction and manufacturing industries.
								Τhey provide a standardized approach to solving common software design problems.
								This analogy helps in understanding the importance and
								utility of design patterns in software development.</p>
						</div>
					</div>
					<div class="fragment">
						<div class="typesetting">
							<ul>
								<li><strong class="important">Construction Templates:</strong>
									In construction, <span class="important">templates and blueprints</span>
									guide the building process, ensuring that structures are built to specifications.
									Similarly, design patterns guide software architecture,
									ensuring that components work together seamlessly</li>
								<li><strong class="important">Manufacturing Molds:</strong>
									In manufacturing, <span class="important">molds</span>
									are used to produce items that are identical in shape and size,
									allowing for efficiency and uniformity.
									In software, design patterns ensure that code structures and algorithms
									are applied consistently, improving code quality and maintainability</li>
							</ul>
						</div>
					</div>
				</section>
				<section>
					<h3 style="text-align: left">Categories of Design Patterns</h3>
					<ul>
						<li class="fragment"><strong class="important">Creational Patterns:</strong>
							Focus on object creation mechanisms, streamlining the instantiation process.
							Examples include Singleton, Factory Method, Abstract Factory, Builder, and Prototype.</li>
						<li class="fragment"><strong class="important">Structural Patterns:</strong>
							Deal with arranging objects and classes into larger structures,
							while maintaining flexibility and efficiency.
							Examples include Adapter, Composite, Proxy, Flyweight, Facade, Bridge, and Decorator.</li>
						<li class="fragment"><strong class="important">Behavioral Patterns:</strong>
							Concerned with efficient communication and the assignment of responsibilities between objects.
							Examples include Strategy, Observer, Command, Iterator, State, Visitor, Template Method,
							Mediator, and Memento.</li>
						<li class="fragment"><strong class="important">Concurrency Patterns:</strong>
							Address multi-threading issues and improve the performance of applications
							in concurrent environments. Examples include Producer-Consumer, Readers-Writers,
							and Dining Philosophers.</li>
					</ul>
				</section>
				<section>
					<h3 style="text-align: left">Example Application of Patterns in Software Frameworks</h3>
					<div class="fragment">
						<div class="typesetting">
							<ul>
								<li><strong class="important">Singleton:</strong> Frameworks use it for managing configurations or connections
									(e.g., database connections in Spring).</li>
								<li><strong class="important">Observer:</strong> Widely used in GUI libraries
									(e.g., event listeners in JavaScript frameworks).</li>
								<li><strong class="important">Factory Method:</strong>
									Creation of objects without exposing the instantiation logic
									(e.g., document object creation in DOM).</li>
								<li><strong class="important">Adapter:</strong>
									Facilitates communication between modern frameworks and
									legacy systems or third-party libraries.</li>
							</ul>
						<p style="text-align: left">These patterns are fundamental in developing robust, scalable, and maintainable software applications.
							<a href="https://www.youtube.com/watch?v=mE3qTp1TEbg&list=PLlsmxlJgn1HJpa28yHzkBmUY-Ty71ZUGc">Here is playlist</a>
							with detailed explanation of each pattern in Java,
							and <a href="https://github.com/avalur/avalur.github.io/tree/master/cs_basics/PatternPractice">here is</a>
							zip-archive with some pattern examples for practice in IDE.</p>
						</p>
						</div>
					</div>
				</section>
				<section>
					<h3 style="text-align: left">Singleton Pattern (Creational)</h3>
					<div class="fragment">
						<div class="typesetting">
							<p style="text-align: left">The Singleton pattern ensures that a class has
								only one instance and provides a global point of access to it.
								This pattern is useful for managing resources like database connections or configurations.</p>
						</div>
					</div>
					<div class="fragment">
						<div class="typesetting">
						<ul>
							<li><strong class="important">Implementation:</strong> Make the constructor private,
								create a static method that contains the instance logic,
								ensuring that only one instance is created and returned.</li>
							<li><strong class="important">Use Cases:</strong> Logging, database connections,
								file managers where a single shared resource is preferable.</li>
							<li><strong class="important">Pros and Cons:</strong>
								Easy implementation, but can introduce global state into an application,
								making it harder to test.</li>
						</ul>
						</div>
					</div>
				</section>
				<section>
					<h3 style="text-align: left">Observer Pattern (Behavioral)</h3>
					<div class="fragment">
						<div class="typesetting">
						<p style="text-align: left">The Observer pattern defines a one-to-many
							dependency between objects so that when one object changes state,
							all its dependents are notified and updated automatically.</p>
						</div>
					</div>
					<div class="fragment">
						<div class="typesetting">
						<ul>
							<li><strong class="important">Implementation:</strong>
								It involves a subject (publisher) and observers (subscribers).
								The subject maintains a list of observers and notifies
								them of changes.</li>
							<li><strong class="important">Use Cases:</strong> GUI tools,
								event management, reactive programming.</li>
							<li><strong class="important">Benefits:</strong>
								Promotes loose coupling, enhancing flexibility and reuse.</li>
						</ul>
						</div>
					</div>
				</section>
				<section>
					<h3 style="text-align: left">Factory Method Pattern (Creational)</h3>
					<div class="fragment">
						<div class="typesetting">
						<p style="text-align: left">The Factory Method Pattern provides an interface
							for creating objects in a superclass but allows subclasses
							to alter the type of objects that will be created.</p>
						</div>
					</div>
					<div class="fragment">
						<div class="typesetting">
							<ul>
								<li><strong class="important">Implementation:</strong> Define an interface for creating an object, but let subclasses decide which class to instantiate. The Factory Method lets a class defer instantiation to subclasses.</li>
								<li><strong class="important">Use Case:</strong> Frameworks, toolkits where library code needs to create objects without knowing the specific types (classes).</li>
								<li><strong class="important">Advantages:</strong> Fosters code reusability and scalability; decouples object creation from its usage.</li>
							</ul>
						</div>
					</div>
				</section>
				<section>
					<h3 style="text-align: left">Adapter Pattern (Structural)</h3>
					<div class="fragment">
						<div class="typesetting">
							<p style="text-align: left">The Adapter Pattern allows incompatible interfaces
							to work together. It acts as a bridge between two incompatible interfaces
							by wrapping itself around the object needing adaptation.</p>
						</div>
					</div>
					<div class="fragment">
						<div class="typesetting">
						<ul>
							<li><strong class="important">Implementation:</strong>
								Involves two classes: an "Adapter" that holds an instance
								of the "Adaptee" class. The adapter implements the target
								interface and translates calls to the adaptee's interface.</li>
							<li><strong class="important">Use Cases:</strong>
								Integration of new features or libraries into existing applications, cross-platform systems.</li>
							<li><strong class="important">Benefits:</strong>
								Increases compatibility between classes without changing their source code.</li>
						</ul>
						</div>
					</div>
				</section>
			</section>
			<section>
				<section>
					<h3 style="text-align: left">Anti-Patterns: Recognizing and Avoiding Pitfalls</h3>
					<div class="fragment">
						<div class="typesetting">
						<ul>
							<li><strong class="important">Definition:</strong> An anti-pattern may be commonly used
								but is ineffective and/or counterproductive in practice.</li>
							<li><strong  class="important">Impact:</strong> Leads to negative consequences,
								making software harder to maintain, less efficient, and more complex.</li>
						</ul>
						</div>
					</div>
				</section>
				<section>
					<h3 style="text-align: left">Common Anti-Patterns</h3>
					<div class="fragment">
						<h4>Code-Level Antipatterns</h4>
						<ul>
							<li><strong class="important">God Object:</strong> Concentrating too many functions in a single part of the design (class).</li>
							<li><strong class="important">Spaghetti Code:</strong> Code with a complex and tangled control structure.</li>
						</ul>
					</div>
					<div class="fragment">
						<br>
						<h4>Architectural Antipatterns</h4>
						<ul>
							<li><strong class="important">Golden Hammer:</strong> Over-reliance on a familiar tool or concept, ignoring more suitable approaches.</li>
							<li><strong class="important">Vendor Lock-in:</strong> Becoming too dependent on a vendor's technologies, making it difficult to switch to another vendor without substantial costs and changes.</li>
							<li><strong class="important">Lava Flow:</strong> Retaining needless code because of uncertainty about its usage, leading to clutter and complexity.</li>
						</ul>
					</div>
				</section>
				<section>
					<h4>Project Management Antipatterns</h4>
					<ul>
						<li><strong class="important">Adding manpower to a late software project:</strong> Often makes it later due to the ramp-up time needed for new team members.</li>
						<li><strong class="important">Silver Bullet:</strong> Belief that a new technology, tool, or practice will solve all problems.</li>
					</ul>
					<img class="fragment" src="images/anti-pattern-meme.png" alt="anti-pattern-meme" width="60%">
				</section>
				<section>
					<h3 style="text-align: left">Strategies to Identify and Refactor Anti-Patterns</h3>
					<div class="fragment">
						<div class="typesetting">
						<p style="text-align: left">Identifying and addressing anti-patterns is crucial
							for maintaining healthy software architecture and project management practices.</p>
						<ul>
							<li><strong class="important">Code Reviews:</strong> Regularly review code with peers to identify complex,
								tightly coupled, or otherwise problematic code early.</li>
							<li><strong class="important">Refactoring:</strong> Systematically improving code or design
								without altering its functionality, to remove anti-patterns and improve maintainability.</li>
							<li><strong class="important">Adopting Best Practices:</strong>
								Stay informed about and adhere to industry best practices for coding, design, and project management.</li>
							<li><strong class="important">Continuous Learning:</strong>
								Encourage a culture of learning and adaptation,
								embracing new and more effective patterns and technologies.</li>
						</ul>
						</div>
					</div>
				</section>
				<section>
					<h3 style="text-align: left">Real cases: Design Patterns in Action</h3>
					<div class="fragment">
						<div class="typesetting">
							<p style="text-align: left"><a href="https://en.wikipedia.org/wiki/Real_Programmers_Don%27t_Use_Pascal">
								Real Programmers Don't Use Pascal</a>, 1982</p>
							<ul>
								<li>Real Programmers do List Processing in FORTRAN.</li>
								<li>Real Programmers do String Manipulation in FORTRAN.</li>
								<li>Real Programmers do Accounting (if they do it at all) in FORTRAN.</li>
								<li>Real Programmers do Artificial Intelligence programs in FORTRAN.</li>
							</ul>
						</div>
					</div>
				</section>
				<section>
					<img src="images/fortran_modules.png" alt="fortran_modules">
				</section>
				<section>
					<h3 style="text-align: left">Fortran Code Example from past century</h3>
					<pre><code class="language-fortran">
      SUBROUTINE ASVOPD(RES,IPR,H1,H2,H3,H,*,NNN)
C*****PAЗЛOЖEHИE BEKTOPA OTHOCИTEЛЬHO PEПEPA
C*****BEPCИЯ: 08 (05.01.99)
      DIMENSION RES(3),H1(3),H2(3),H3(3),H(3)
      DIMENSION IYY(3),IWW(11)
      REAL*8 ROP,R,A
      INTEGER*2 INU(28)
      COMMON IRAS/VOP/ROP(36)
      SAVE
      DATA IYY/0,'ASVO','PD09'/
      DATA IWW/'ВАРИ','АНТ ','НЕ 1','-3  ','****',
     *         'BЫPO','ЖДEH','HЫЙ ','PEПE','P   ','****'/
      DATA INU/2,1,1,1404,405,2000,0,
     *        4,1,1,1,1,1001,506,1002,604,1003,405,-108,207,-109,307,
     *        -107,107,-101,104,2000,0/
      DATA Y/7777777777./
      CALL ATRASW(0,IYY)
      SELECT CASE(IPR)
      CASE(1,2)
C.....разложение по реперу
         IF(IPR.EQ.2) CALL ASVOPM(H3,INU,H1,H2,Y,Y,Y,Y,Y,Y,*100,1)
         CALL ASVOPM(RES,INU(8),H1,H2,H3,H,Y,Y,Y,Y,*100,2)
         R=ROP(1)
         DO I=1,3
            A=ROP(I+6)
            IF(R.EQ.0.OR.DABS(A)*1E-20.GT.DABS(R)) GOTO 102
            RES(I)=A/R
         ENDDO
      CASE(3)
C.....линейная комбинация векторов репера
         DO I=1,3
            RES(I)=H(1)*H1(I)+H(2)*H2(I)+H(3)*H3(I)
         ENDDO
C.....ошибочное значение IPR
      CASE DEFAULT
         GOTO 101
      ENDSELECT
      RETURN
C.....обработка аварийных ситуаций
  102 IRAS=IRAS+1
  101 IRAS=IRAS+1
  100 CALL ATRAS(IYY(2),IWW,NNN)
      RETURN 1
      END
					</code></pre>
				</section>
				<section>
					<h3 style="text-align: left">Fortran Code Example from our century</h3>
					<pre><code class="language-fortran">
c    В этом файле содержится процедура Solve_ke_equations для
c    расчета уравнений на характеристики турбулентности k и eps,
c    а также вспомогательные процедуры CF_IN, CF_VIS, Find_Ge_wall и Find_eps_nw.
c    Реализована стандартная k-e модель турбулентности.

      SUBROUTINE Solve_ke_equations(K1,K2,K3,TLOC,
     *                 QP,SIX,SIY,SIZ,SJX,SJY,SJZ,SKX,SKY,SKZ,V,
     *                 X,Y,Z,KRT1,KRT2,YPI,YPJ,YPK,TK,TE,ResMK,ResME,
     *                 ResKMax,ResEMax,INTPAR,REALPAR,
     *                 BLOCK_SYMBOL,TurbineType,IsPrint,NDOMN,IError)

      USE OUTMOD
      IMPLICIT REAL*8 (A-H,O-Z)
      INCLUDE 'EXY'
      INTEGER SourceType,SumJK,SumIJK
      REAL*8 nu_wall
      CHARACTER*1 BLOCK_SYMBOL,TurbineType
      LOGICAL IsPrint,ReturnFlag
C     Объявление внешних массивов
      DIMENSION QP(KM,KA11,KA21,KA31), V(KA11,KA21,KA31),
     *SIX(KA1,KA21,KA31),SIY(KA1,KA21,KA31),SIZ(KA1,KA21,KA31),
     *SJX(KA11,KA2,KA31),SJY(KA11,KA2,KA31),SJZ(KA11,KA2,KA31),
     *SKX(KA11,KA21,KA3),SKY(KA11,KA21,KA3),SKZ(KA11,KA21,KA3),
     *X(KA11,KA21,KA31),Y(KA11,KA21,KA31),Z(KA11,KA21,KA31),
     *KRT1(KA11,KA21,3),KRT2(KA11,KA21,3),
     *YPI(2,KA21,KA31),YPJ(2,KA11,KA31),YPK(2,KA11,KA21),
     *TK(KA11,KA21,KA31),TE(KA11,KA21,KA31),
     *ResMK(KA11,KA21,KA31),ResME(KA11,KA21,KA31),
     *INTPAR(50),REALPAR(50),
     *TLOC(KA11,KA21,KA31)


C     Объявление внутренних массивов
      DIMENSION
     *  PSYmK(KA11,KA21,KA31),dPsiK(KA11,KA21,KA31),
     *  PSYmE(KA11,KA21,KA31),dPsiE(KA11,KA21,KA31),
     *  RHSK(KA11,KA21,KA31),RHSE(KA11,KA21,KA31),
     *  VEI(KA1,KA21,KA31),VEJ(KA11,KA2,KA31),VEK(KA11,KA21,KA3),
     *  Qc(KM),Qir(KM),Qif(KM),Qjr(KM),Qjf(KM),Qkr(KM),Qkf(KM),
     *  FNKjr(KA11),FVKjr(KA11),FNEjr(KA11),FVEjr(KA11),
     *  DKM(KA11,KA21,KA31),CifKM(KA11,KA21,KA31),CjfKM(KA11,KA21,KA31),
     *  CkfKM(KA11,KA21,KA31),CirKM(KA11,KA21,KA31),
     *  CjrKM(KA11,KA21,KA31),CkrKM(KA11,KA21,KA31),
     *  DEM(KA11,KA21,KA31),CifEM(KA11,KA21,KA31),CjfEM(KA11,KA21,KA31),
     *  CkfEM(KA11,KA21,KA31),CirEM(KA11,KA21,KA31),
     *  CjrEM(KA11,KA21,KA31),CkrEM(KA11,KA21,KA31),
     *  SI(3),SJ(3),SK(3),QcM(KM),TKLoc(27),TELoc(27),KSDV(6,3)

      COMMON /turb/ Cmu,Ceps1,Ceps2,SigmaK,SigmaE,Ckar,CE,Ceps3

      K11=K1-1
      K21=K2-1
      K31=K3-1
      K12=K11-1
      K22=K21-1
      K32=K31-1
      K13=K12-1
      K23=K22-1
      K33=K32-1
      K14=K13-1
      K24=K23-1
      K34=K33-1
      K15=K14-1

      ITN1 = INTPAR(4)
      ITN2 = INTPAR(5)
      IZNAK= INTPAR(11)
      OM   = REALPAR(8)
      Reyn = REALPAR(13)
      Rsrez= REALPAR(16)

      nz_begin= INTPAR(33)
      nz_end  = INTPAR(34)

      vlam=1.d0/Reyn
      Kvis=1
      VeryLargeNumber=10.e+30
      ReturnFlag = .false.

cc==== Turbulence model parameters =====
c      Cmu   =0.09d0
c      Ceps1 =1.44d0
c      Ceps2 =1.92d0
c      SigmaK=1.0d0
c      SigmaE=1.3d0
c      Ckar  =0.4d0
c      CE    =9.0d0
cc======================================

!$omp parallel default(none)
!$omp& shared(QP,TK,TE,VEI,VEJ,VEK,PSYmK,PSYmE,TLOC,V,X,Y,Z)
!$omp& shared(SIX,SIY,SIZ,SJX,SJY,SJZ,SKX,SKY,SKZ,INTPAR,REALPAR)
!$omp& shared(YPI,YPJ,YPK,KRT1,KRT2)
!$omp& shared(RHSK,RHSE,ResMK,ResME)
!$omp& shared(CirKM,CjrKM,CkrKM,CifKM,CjfKM,CkfKM)
!$omp& shared(CirEM,CjrEM,CkrEM,CifEM,CjfEM,CkfEM)
!$omp& shared(DKM,DEM,dPsiK,dPsiE)
!$omp& private(vlam,tke_c,tke_ir,tke_jr,tke_kr)
!$omp& private(Qc,Qir,Qjr,Qkr,Qif,Qjf,Qkf,TAU)
!$omp& private(TKc,TKir,TKjr,TKkr,TKif,TKjf,TKkf)
!$omp& private(TEc,TEir,TEjr,TEkr,TEif,TEjf,TEkf)
!$omp& private(TK_mm,TE_mm,I_mm,J_mm,K_mm,IError,IWarn)
!$omp& private(SIXr,SIYr,SIZr,SJXr,SJYr,SJZr,SKXr,SKYr,SKZr)
!$omp& private(SIXf,SIYf,SIZf,SJXf,SJYf,SJZf,SKXf,SKYf,SKZf)
!$omp& private(Air,Apir,Amir,Ajr,Apjr,Amjr,Akr,Apkr,Amkr)
!$omp& private(Aif,Apif,Amif,Ajf,Apjf,Amjf,Akf,Apkf,Amkf)
!$omp& private(Volc,Volir,Voljr,Volkr,Volif,Voljf,Volkf)
!$omp& private(vKir,vKjr,vKkr,vKif,vKjf,vKkf)
!$omp& private(vEir,vEjr,vEkr,vEif,vEjf,vEkf)
!$omp& private(SSVir,SSVjr,SSVkr,SSVif,SSVjf,SSVkf)
!$omp& private(BirK,BjrK,BkrK,BifK,BjfK,BkfK)
!$omp& private(BirE,BjrE,BkrE,BifE,BjfE,BkfE)
!$omp& private(CirK,CjrK,CkrK,CifK,CjfK,CkfK)
!$omp& private(CirE,CjrE,CkrE,CifE,CjfE,CkfE)
!$omp& private(XX,YY,RR,isKcorner,DK,DE)
!$omp& private(FK0,FNKir,FNKjr,FNKkr,FNKif,FNKjf,FNKkf)
!$omp& private(FE0,FNEir,FNEjr,FNEkr,FNEif,FNEjf,FNEkf)
!$omp& private(IMM,IPP,KMM,KPP,JMM,JPP,Inn,Jnn,Knn)
!$omp& private(SI,SJ,SK)
!$omp& private(FVKir,FVKjr,FVKkr,FVKif,FVKjf,FVKkf)
!$omp& private(FVEir,FVEjr,FVEkr,FVEif,FVEjf,FVEkf)
!$omp& private(ddj,ddk,Q1K,Q2K,Q3K,Q1E,Q2E,Q3E)
!$omp& private(uim,ujm,ukm,vim,vjm,vkm,wim,wjm,wkm)
!$omp& private(uip,ujp,ukp,vip,vjp,vkp,wip,wjp,wkp)
!$omp& private(ux,uy,uz,vx,vy,vz,wx,wy,wz)
!$omp& private(vt,gg,Smod,GG_K,eps,eps1,SrcK,SrcE,HK,HE,eps_nw)
!$omp& private(VolEff,isIwall,isJwall,isKwall,SourceType)
!$omp& private(Krot,Xw,Yw,Zw,IP,QcM,ResK,ResE)
!$omp& private(NKnegCorr,NEnegCorr,NEcutCorr,KSDV)
!$omp& private(TKsum,MP,is,ks,js,TELoc,TEmin,TEmedium,TEcut)
!$omp& private(vtc,vtir,vtif,vtjr,vtjf,vtkr,vtkf,vtmax)
!$omp& firstprivate(ReturnFlag,IZNAK,Reyn,NDOMN,nz_begin)
!$omp& firstprivate(Cmu,SigmaK,SigmaE,Ceps1,Ceps2,Ceps3)
!$omp& firstprivate(BLOCK_SYMBOL,OM,Ckar,CE,TurbineType,Rsrez)
!$omp& firstprivate(VeryLargeNumber)
!$omp& firstprivate(K1,K2,K3,K11,K21,K31,K12,K22,K32,K13,K23,K33)
!$omp& reduction(max: ResKMax, ResEMax)
!$omp& reduction(+: SumDivK, SumDivE, SumVol)

!$omp do
      DO 120 k=3,K32
      DO 120 j=3,K22
      DO 120 i=3,K12
        tke_c =(TK(i,j,k  )**2)/TE(i,j,k)
        tke_ir=(TK(i-1,j,k)**2)/TE(i-1,j,k)
        tke_jr=(TK(i,j-1,k)**2)/TE(i,j-1,k)
        tke_kr=(TK(i,j,k-1)**2)/TE(i,j,k-1)
        VEI(i,j,k) = vlam+0.5d0*Cmu*(tke_c+tke_ir)
        VEJ(i,j,k) = vlam+0.5d0*Cmu*(tke_c+tke_jr)
        VEK(i,j,k) = vlam+0.5d0*Cmu*(tke_c+tke_kr)
120   CONTINUE

      ResKMax= 0.d0
      ResEMax= 0.d0
      SumDivK= 0.d0
      SumDivE= 0.d0
      SumVol = 0.d0

C***** Boundary conditions for PSYmK and PSYmE ***********
!$omp do
      DO 370 j=3,K23
      DO 370 i=3,K13
          PSYmK(i,j,2)=0.d0
370       PSYmE(i,j,2)=0.d0
!$omp do
      DO 380 k=3,K33
      DO 380 j=3,K23
          PSYmK(2,j,k)=0.d0
380       PSYmE(2,j,k)=0.d0
!$omp do
      DO 390 k=3,K33
      DO 390 i=3,K13
          PSYmK(i,2,k)=0.d0
390       PSYmE(i,2,k)=0.d0

c      write(*,*)(' UP - started')

c=================================================================
C******* РАСЧЕТ НЕВЯЗКИ RHS ВО ВСЕЙ ОБЛАСТИ ********************
!$omp do
      DO 560 k=3,K33
      DO 560 j=3,K23
      DO 560 i=3,K13
c       write(*,*)i,j,k

C******* Block of calculation nearest Q, TK, TE ******************
       DO 405 m=1,4
         Qc (m)=QP(m,i,j,k)
         Qir(m)=QP(m,i-1,j,k)
         Qjr(m)=QP(m,i,j-1,k)
         Qkr(m)=QP(m,i,j,k-1)
         Qif(m)=QP(m,i+1,j,k)
         Qjf(m)=QP(m,i,j+1,k)
         Qkf(m)=QP(m,i,j,k+1)
405    CONTINUE

       TAU=TLOC(i,j,k)

       TKc =TK(i,j,k)
       TKir=TK(i-1,j,k)
       TKjr=TK(i,j-1,k)
       TKkr=TK(i,j,k-1)
       TKif=TK(i+1,j,k)
       TKjf=TK(i,j+1,k)
       TKkf=TK(i,j,k+1)

       TEc =TE(i,j,k)
       TEir=TE(i-1,j,k)
       TEjr=TE(i,j-1,k)
       TEkr=TE(i,j,k-1)
       TEif=TE(i+1,j,k)
       TEjf=TE(i,j+1,k)
       TEkf=TE(i,j,k+1)

       if(TKc.LT.1.e-16) then
         TK_mm=TKc
         I_mm=i
         J_mm=j
         K_mm=k
C        Выдаем ошибку: TK <= 0.
         CALL OUTER(123,'E',IError,IWarn)
         if(IError.NE.0) ReturnFlag = .true.
       endif
       if(TEc.LT.1.e-16) then
         TE_mm=TEc
         I_mm=i
         J_mm=j
         K_mm=k
C        Выдаем ошибку: TE <= 0.
         CALL OUTER(124,'E',IError,IWarn)
         if(IError.NE.0) ReturnFlag = .true.
       endif

       SIXr=SIX(i,j,k)
       SIYr=SIY(i,j,k)
       SIZr=SIZ(i,j,k)
       SJXr=SJX(i,j,k)
       SJYr=SJY(i,j,k)
       SJZr=SJZ(i,j,k)
       SKXr=SKX(i,j,k)
       SKYr=SKY(i,j,k)
       SKZr=SKZ(i,j,k)
       SIXf=SIX(i+1,j,k)
       SIYf=SIY(i+1,j,k)
       SIZf=SIZ(i+1,j,k)
       SJXf=SJX(i,j+1,k)
       SJYf=SJY(i,j+1,k)
       SJZf=SJZ(i,j+1,k)
       SKXf=SKX(i,j,k+1)
       SKYf=SKY(i,j,k+1)
       SKZf=SKZ(i,j,k+1)
c      write(*,*)('Nearest TK,TE -DONE')

C***** A-scalars ******************************************
C***** A-scalars are the Jacobians of inviscid fluxes *****
       Air=0.5d0*((Qir(2)+Qc(2))*SIXr+
     *            (Qir(3)+Qc(3))*SIYr+
     *            (Qir(4)+Qc(4))*SIZr)
       Apir=0.5d0*(Air+DABS(Air))

       Ajr=0.5d0*((Qjr(2)+Qc(2))*SJXr+
     *            (Qjr(3)+Qc(3))*SJYr+
     *            (Qjr(4)+Qc(4))*SJZr)
       Apjr=0.5d0*(Ajr+DABS(Ajr))

       Akr=0.5d0*((Qkr(2)+Qc(2))*SKXr+
     *            (Qkr(3)+Qc(3))*SKYr+
     *            (Qkr(4)+Qc(4))*SKZr)
       Apkr=0.5d0*(Akr+DABS(Akr))

       Aif=0.5d0*((Qc(2)+Qif(2))*SIXf+
     *            (Qc(3)+Qif(3))*SIYf+
     *            (Qc(4)+Qif(4))*SIZf)
       Amif=0.5d0*(Aif-DABS(Aif))

       Ajf=0.5d0*((Qc(2)+Qjf(2))*SJXf+
     *            (Qc(3)+Qjf(3))*SJYf+
     *            (Qc(4)+Qjf(4))*SJZf)
       Amjf=0.5d0*(Ajf-DABS(Ajf))

       Akf=0.5d0*((Qc(2)+Qkf(2))*SKXf+
     *            (Qc(3)+Qkf(3))*SKYf+
     *            (Qc(4)+Qkf(4))*SKZf)
       Amkf=0.5d0*(Akf-DABS(Akf))

c      write(*,*)('A -DONE')

C***** B-scalars ******************************************
C***** B-scalars are the Jacobians of viscous fluxes ******
       Volc=V(i,j,k)
       Volir=0.5d0*(Volc+V(i-1,j,k))
       Volif=0.5d0*(Volc+V(i+1,j,k))
       Voljr=0.5d0*(Volc+V(i,j-1,k))
       Voljf=0.5d0*(Volc+V(i,j+1,k))
       Volkr=0.5d0*(Volc+V(i,j,k-1))
       Volkf=0.5d0*(Volc+V(i,j,k+1))

       vKir=vlam+(VEI(i,j,k)-vlam)/SigmaK
       vKjr=vlam+(VEJ(i,j,k)-vlam)/SigmaK
       vKkr=vlam+(VEK(i,j,k)-vlam)/SigmaK
       vKif=vlam+(VEI(i+1,j,k)-vlam)/SigmaK
       vKjf=vlam+(VEJ(i,j+1,k)-vlam)/SigmaK
       vKkf=vlam+(VEK(i,j,k+1)-vlam)/SigmaK
       vEir=vlam+(VEI(i,j,k)-vlam)/SigmaE
       vEjr=vlam+(VEJ(i,j,k)-vlam)/SigmaE
       vEkr=vlam+(VEK(i,j,k)-vlam)/SigmaE
       vEif=vlam+(VEI(i+1,j,k)-vlam)/SigmaE
       vEjf=vlam+(VEJ(i,j+1,k)-vlam)/SigmaE
       vEkf=vlam+(VEK(i,j,k+1)-vlam)/SigmaE

C      Коррекция вязкостей vK и vE в ячейках, прилегающих к твердым стенкам
       if((i.EQ.3).AND.(IZNAK.EQ.1)) then
         vKir=vlam+VEI(i,j,k)/SigmaK
         vEir=vlam+VEI(i,j,k)/SigmaE
       endif

       if(j.eq.3) then
         vKjr=vlam+VEJ(i,j,k)/SigmaK
         vEjr=vlam+VEJ(i,j,k)/SigmaE
       endif

       XX=0.5d0*(X(I,J,K)+X(I,J+1,K))
       YY=0.5d0*(Y(I,J,K)+Y(I,J+1,K))
       RR=DSQRT(XX**2+YY**2)
       if((J.eq.K23).and.
     *   ((BLOCK_SYMBOL.ne.'k').or.(RR.ge.Rsrez))) then
         vKjf=vlam+VEJ(i,j+1,k)/SigmaK
         vEjf=vlam+VEJ(i,j+1,k)/SigmaE
       endif
       if((k.eq.3).and.(KRT2(i,j,1).eq.1)) then
         vKkr=vlam+VEK(i,j,k)/SigmaK
         vEkr=vlam+VEK(i,j,k)/SigmaE
       endif
       if((k.eq.K33).and.(KRT1(i,j,1).eq.1)) then
         vKkf=vlam+VEK(i,j,k+1)/SigmaK
         vEkf=vlam+VEK(i,j,k+1)/SigmaE
       endif

       SSVir=(SIXr**2+SIYr**2+SIZr**2)/Volir
       SSVjr=(SJXr**2+SJYr**2+SJZr**2)/Voljr
       SSVkr=(SKXr**2+SKYr**2+SKZr**2)/Volkr
       SSVif=(SIXf**2+SIYf**2+SIZf**2)/Volif
       SSVjf=(SJXf**2+SJYf**2+SJZf**2)/Voljf
       SSVkf=(SKXf**2+SKYf**2+SKZf**2)/Volkf

       BirK= -vKir*SSVir
       BjrK= -vKjr*SSVjr
       BkrK= -vKkr*SSVkr
       BifK= -vKif*SSVif
       BjfK= -vKjf*SSVjf
       BkfK= -vKkf*SSVkf

       BirE= -vEir*SSVir
       BjrE= -vEjr*SSVjr
       BkrE= -vEkr*SSVkr
       BifE= -vEif*SSVif
       BjfE= -vEjf*SSVjf
       BkfE= -vEkf*SSVkf
c       write(*,*)('B -DONE')

C***** ВЫЧИСЛЕНИЕ НЕВЯЗКИХ ПОТОКОВ ДЛЯ К и E-УРАВНЕНИЙ *****************

C===== Грань i+1/2 ===================================================
       CALL CF_IN(Qc,Qif,TKc,TKif,SIXf,SIYf,SIZf,FNKif)
       CALL CF_IN(Qc,Qif,TEc,TEif,SIXf,SIYf,SIZf,FNEif)
C      write(*,*)(' FNKif')

C===== Грань j+1/2 ===================================================
       CALL CF_IN(Qc,Qjf,TKc,TKjf,SJXf,SJYf,SJZf,FNKjf)
       CALL CF_IN(Qc,Qjf,TEc,TEjf,SJXf,SJYf,SJZf,FNEjf)
C      write(*,*)(' FNKjf')

C===== Грань k+1/2 ===================================================
       CALL CF_IN(Qc,Qkf,TKc,TKkf,SKXf,SKYf,SKZf,FNKkf)
       CALL CF_IN(Qc,Qkf,TEc,TEkf,SKXf,SKYf,SKZf,FNEkf)
C      write(*,*)(' FNKkf')

C===== Грань i-1/2 ===================================================
       if(i.EQ.3) then
         CALL CF_IN(Qir,Qc,TKir,TKc,SIXr,SIYr,SIZr,FNKir)
         CALL CF_IN(Qir,Qc,TEir,TEc,SIXr,SIYr,SIZr,FNEir)
C        write(*,*)(' FNKir')
       endif

C===== Грань j-1/2 ===================================================
       if(j.EQ.3) then
         CALL CF_IN(Qjr,Qc,TKjr,TKc,SJXr,SJYr,SJZr,FK0)
         CALL CF_IN(Qjr,Qc,TEjr,TEc,SJXr,SJYr,SJZr,FE0)
C        write(*,*)(' FNKjr')
         FNKjr(i)=FK0
         FNEjr(i)=FE0
       endif

C===== Грань k-1/2 ===================================================
c       if(k.EQ.3) then
         CALL CF_IN(Qkr,Qc,TKkr,TKc,SKXr,SKYr,SKZr,FK0)
         CALL CF_IN(Qkr,Qc,TEkr,TEc,SKXr,SKYr,SKZr,FE0)
C        write(*,*)(' FNKkr')
         FNKkr=FK0
         FNEkr=FE0
c       endif

c       write(*,*)('FN -DONE')

C***********************************************************************
C     ВЫЧИСЛЕНИЕ ВЯЗКИХ ПОТОКОВ

C======ВЯЗКИЙ ПОТОК ЧЕРЕЗ ГРАНЬ i+1/2=========================
       jmm=j-1
       jpp=j+1
       kmm=k-1
       kpp=k+1
       ddj=0.25d0
       ddk=0.25d0
       if(k.eq.3)   then
          kmm=k
          ddk=0.5d0
       endif
       if(k.eq.K33) then
          kpp=k
          ddk=0.5d0
       endif
       Q1K= TKif-TKc
       Q2K=ddj*(TK(i  ,jpp,k)-TK(i  ,jmm,k)+
     *          TK(i+1,jpp,k)-TK(i+1,jmm,k))
       Q3K=ddk*(TK(i  ,j,kpp)-TK(i  ,j,kmm)+
     *          TK(i+1,j,kpp)-TK(i+1,j,kmm))
C      --------------------------------------
       Q1E= TEif-TEc
       Q2E=ddj*(TE(i  ,jpp,k)-TE(i  ,jmm,k)+
     *          TE(i+1,jpp,k)-TE(i+1,jmm,k))
       Q3E=ddk*(TE(i  ,j,kpp)-TE(i  ,j,kmm)+
     *          TE(i+1,j,kpp)-TE(i+1,j,kmm))
      SI(1)=SIXf
      SI(2)=SIYf
      SI(3)=SIZf
      SJ(1)=(SJX(i,j+1,k)+SJX(i+1,j+1,k)+SJX(i,j,k)+SJX(i+1,j,k))/4.d0
      SJ(2)=(SJY(i,j+1,k)+SJY(i+1,j+1,k)+SJY(i,j,k)+SJY(i+1,j,k))/4.d0
      SJ(3)=(SJZ(i,j+1,k)+SJZ(i+1,j+1,k)+SJZ(i,j,k)+SJZ(i+1,j,k))/4.d0
      SK(1)=(SKX(i,j,k+1)+SKX(i+1,j,k+1)+SKX(i,j,k)+SKX(i+1,j,k))/4.d0
      SK(2)=(SKY(i,j,k+1)+SKY(i+1,j,k+1)+SKY(i,j,k)+SKY(i+1,j,k))/4.d0
      SK(3)=(SKZ(i,j,k+1)+SKZ(i+1,j,k+1)+SKZ(i,j,k)+SKZ(i+1,j,k))/4.d0
      CALL CF_VIS(Q1K,Q2K,Q3K,SI,SJ,SK,Volif,SI,vKif,FVKif)
      CALL CF_VIS(Q1E,Q2E,Q3E,SI,SJ,SK,Volif,SI,vEif,FVEif)

C======ВЯЗКИЙ ПОТОК ЧЕРЕЗ ГРАНЬ j+1/2=========================
       Q1K=(TK(i+1,j,k)  -TK(i-1,j,k)+
     *      TK(i+1,j+1,k)-TK(i-1,j+1,k))/4.d0
       Q2K= TKjf-TKc
       Q3K=(TK(i,j,k+1)  -TK(i,j,k-1)+
     *      TK(i,j+1,k+1)-TK(i,j+1,k-1))/4.d0
C      --------------------------------------
       Q1E=(TE(i+1,j,k)  -TE(i-1,j,k)+
     *      TE(i+1,j+1,k)-TE(i-1,j+1,k))/4.d0
       Q2E= TEjf-TEc
       Q3E=(TE(i,j,k+1)  -TE(i,j,k-1)+
     *      TE(i,j+1,k+1)-TE(i,j+1,k-1))/4.d0
      SI(1)=(SIX(i+1,j,k)+SIX(i+1,j+1,k)+SIX(i,j,k)+SIX(i,j+1,k))/4.d0
      SI(2)=(SIY(i+1,j,k)+SIY(i+1,j+1,k)+SIY(i,j,k)+SIY(i,j+1,k))/4.d0
      SI(3)=(SIZ(i+1,j,k)+SIZ(i+1,j+1,k)+SIZ(i,j,k)+SIZ(i,j+1,k))/4.d0
      SJ(1)=SJXf
      SJ(2)=SJYf
      SJ(3)=SJZf
      SK(1)=(SKX(i,j,k+1)+SKX(i,j+1,k+1)+SKX(i,j,k)+SKX(i,j+1,k))/4.d0
      SK(2)=(SKY(i,j,k+1)+SKY(i,j+1,k+1)+SKY(i,j,k)+SKY(i,j+1,k))/4.d0
      SK(3)=(SKZ(i,j,k+1)+SKZ(i,j+1,k+1)+SKZ(i,j,k)+SKZ(i,j+1,k))/4.d0
      CALL CF_VIS(Q1K,Q2K,Q3K,SI,SJ,SK,Voljf,SJ,vKjf,FVKjf)
      CALL CF_VIS(Q1E,Q2E,Q3E,SI,SJ,SK,Voljf,SJ,vEjf,FVEjf)

C======ВЯЗКИЙ ПОТОК ЧЕРЕЗ ГРАНЬ k+1/2=========================
       Q1K=(TK(i+1,j,k)  -TK(i-1,j,k)+
     *      TK(i+1,j,k+1)-TK(i-1,j,k+1))/4.d0
       Q2K=(TK(i,j+1,k)  -TK(i,j-1,k)+
     *      TK(i,j+1,k+1)-TK(i,j-1,k+1))/4.d0
       Q3K= TKkf-TKc
C      --------------------------------------
       Q1E=(TE(i+1,j,k)  -TE(i-1,j,k)+
     *      TE(i+1,j,k+1)-TE(i-1,j,k+1))/4.d0
       Q2E=(TE(i,j+1,k)  -TE(i,j-1,k)+
     *      TE(i,j+1,k+1)-TE(i,j-1,k+1))/4.d0
       Q3E= TEkf-TEc
      SI(1)=(SIX(i+1,j,k)+SIX(i+1,j,k+1)+SIX(i,j,k)+SIX(i,j,k+1))/4.d0
      SI(2)=(SIY(i+1,j,k)+SIY(i+1,j,k+1)+SIY(i,j,k)+SIY(i,j,k+1))/4.d0
      SI(3)=(SIZ(i+1,j,k)+SIZ(i+1,j,k+1)+SIZ(i,j,k)+SIZ(i,j,k+1))/4.d0
      SJ(1)=(SJX(i,j+1,k)+SJX(i,j+1,k+1)+SJX(i,j,k)+SJX(i,j,k+1))/4.d0
      SJ(2)=(SJY(i,j+1,k)+SJY(i,j+1,k+1)+SJY(i,j,k)+SJY(i,j,k+1))/4.d0
      SJ(3)=(SJZ(i,j+1,k)+SJZ(i,j+1,k+1)+SJZ(i,j,k)+SJZ(i,j,k+1))/4.d0
      SK(1)=SKXf
      SK(2)=SKYf
      SK(3)=SKZf
      CALL CF_VIS(Q1K,Q2K,Q3K,SI,SJ,SK,Volkf,SK,vKkf,FVKkf)
      CALL CF_VIS(Q1E,Q2E,Q3E,SI,SJ,SK,Volkf,SK,vEkf,FVEkf)

C======ВЯЗКИЙ ПОТОК ЧЕРЕЗ ГРАНЬ i-1/2=========================
      if(i.EQ.3) then
       jmm=j-1
       jpp=j+1
       kmm=k-1
       kpp=k+1
       ddj=0.25d0
       ddk=0.25d0
       if(k.eq.3)   then
          kmm=k
          ddk=0.5d0
       endif
       if(k.eq.K33) then
          kpp=k
          ddk=0.5d0
       endif
       Q1K= TKc-TKir
       Q2K=ddj*(TK(i-1,jpp,k)-TK(i-1,jmm,k)+
     *          TK(i  ,jpp,k)-TK(i  ,jmm,k))
       Q3K=ddk*(TK(i-1,j,kpp)-TK(i-1,j,kmm)+
     *          TK(i  ,j,kpp)-TK(i  ,j,kmm))
C      --------------------------------------
       Q1E= TEc-TEir
       Q2E=ddj*(TE(i-1,jpp,k)-TE(i-1,jmm,k)+
     *          TE(i  ,jpp,k)-TE(i  ,jmm,k))
       Q3E=ddk*(TE(i-1,j,kpp)-TE(i-1,j,kmm)+
     *          TE(i  ,j,kpp)-TE(i  ,j,kmm))
      SI(1)=SIXr
      SI(2)=SIYr
      SI(3)=SIZr
      SJ(1)=(SJX(i-1,j+1,k)+SJX(i,j+1,k)+SJX(i-1,j,k)+SJX(i,j,k))/4.d0
      SJ(2)=(SJY(i-1,j+1,k)+SJY(i,j+1,k)+SJY(i-1,j,k)+SJY(i,j,k))/4.d0
      SJ(3)=(SJZ(i-1,j+1,k)+SJZ(i,j+1,k)+SJZ(i-1,j,k)+SJZ(i,j,k))/4.d0
      SK(1)=(SKX(i-1,j,k+1)+SKX(i,j,k+1)+SKX(i-1,j,k)+SKX(i,j,k))/4.d0
      SK(2)=(SKY(i-1,j,k+1)+SKY(i,j,k+1)+SKY(i-1,j,k)+SKY(i,j,k))/4.d0
      SK(3)=(SKZ(i-1,j,k+1)+SKZ(i,j,k+1)+SKZ(i-1,j,k)+SKZ(i,j,k))/4.d0
      CALL CF_VIS(Q1K,Q2K,Q3K,SI,SJ,SK,Volir,SI,vKir,FVKir)
      CALL CF_VIS(Q1E,Q2E,Q3E,SI,SJ,SK,Volir,SI,vEir,FVEir)
      end if

C======ВЯЗКИЙ ПОТОК ЧЕРЕЗ ГРАНЬ j-1/2=========================
      if(j.EQ.3) then
       Q1K=(TK(i+1,j-1,k)-TK(i-1,j-1,k)+
     *      TK(i+1,j,k)  -TK(i-1,j,k))/4.d0
       Q2K= TKc-TKjr
       Q3K=(TK(i,j-1,k+1)-TK(i,j-1,k-1)+
     *      TK(i,j,k+1)  -TK(i,j,k-1))/4.d0
C      --------------------------------------
       Q1E=(TE(i+1,j-1,k)-TE(i-1,j-1,k)+
     *      TE(i+1,j,k)  -TE(i-1,j,k))/4.d0
       Q2E= TEc-TEjr
       Q3E=(TE(i,j-1,k+1)-TE(i,j-1,k-1)+
     *      TE(i,j,k+1)  -TE(i,j,k-1))/4.d0
      SI(1)=(SIX(i+1,j-1,k)+SIX(i+1,j,k)+SIX(i,j-1,k)+SIX(i,j,k))/4.d0
      SI(2)=(SIY(i+1,j-1,k)+SIY(i+1,j,k)+SIY(i,j-1,k)+SIY(i,j,k))/4.d0
      SI(3)=(SIZ(i+1,j-1,k)+SIZ(i+1,j,k)+SIZ(i,j-1,k)+SIZ(i,j,k))/4.d0
      SJ(1)=SJXr
      SJ(2)=SJYr
      SJ(3)=SJZr
      SK(1)=(SKX(i,j-1,k+1)+SKX(i,j,k+1)+SKX(i,j-1,k)+SKX(i,j,k))/4.d0
      SK(2)=(SKY(i,j-1,k+1)+SKY(i,j,k+1)+SKY(i,j-1,k)+SKY(i,j,k))/4.d0
      SK(3)=(SKZ(i,j-1,k+1)+SKZ(i,j,k+1)+SKZ(i,j-1,k)+SKZ(i,j,k))/4.d0
      CALL CF_VIS(Q1K,Q2K,Q3K,SI,SJ,SK,Voljr,SJ,vKjr,FK0)
      CALL CF_VIS(Q1E,Q2E,Q3E,SI,SJ,SK,Voljr,SJ,vEjr,FE0)
      FVKjr(i)=FK0
      FVEjr(i)=FE0
      end if

C======ВЯЗКИЙ ПОТОК ЧЕРЕЗ ГРАНЬ k-1/2=========================
c      if(k.EQ.3) then
       Q1K=(TK(i+1,j,k-1)-TK(i-1,j,k-1)+
     *      TK(i+1,j,k)  -TK(i-1,j,k))/4.d0
       Q2K=(TK(i,j+1,k-1)-TK(i,j-1,k-1)+
     *      TK(i,j+1,k)  -TK(i,j-1,k))/4.d0
       Q3K= TKc-TKkr
C      --------------------------------------
       Q1E=(TE(i+1,j,k-1)-TE(i-1,j,k-1)+
     *      TE(i+1,j,k)  -TE(i-1,j,k))/4.d0
       Q2E=(TE(i,j+1,k-1)-TE(i,j-1,k-1)+
     *      TE(i,j+1,k)  -TE(i,j-1,k))/4.d0
       Q3E= TEc-TEkr
      SI(1)=(SIX(i+1,j,k-1)+SIX(i+1,j,k)+SIX(i,j,k-1)+SIX(i,j,k))/4.d0
      SI(2)=(SIY(i+1,j,k-1)+SIY(i+1,j,k)+SIY(i,j,k-1)+SIY(i,j,k))/4.d0
      SI(3)=(SIZ(i+1,j,k-1)+SIZ(i+1,j,k)+SIZ(i,j,k-1)+SIZ(i,j,k))/4.d0
      SJ(1)=(SJX(i,j+1,k-1)+SJX(i,j+1,k)+SJX(i,j,k-1)+SJX(i,j,k))/4.d0
      SJ(2)=(SJY(i,j+1,k-1)+SJY(i,j+1,k)+SJY(i,j,k-1)+SJY(i,j,k))/4.d0
      SJ(3)=(SJZ(i,j+1,k-1)+SJZ(i,j+1,k)+SJZ(i,j,k-1)+SJZ(i,j,k))/4.d0
      SK(1)=SKXr
      SK(2)=SKYr
      SK(3)=SKZr
      CALL CF_VIS(Q1K,Q2K,Q3K,SI,SJ,SK,Volkr,SK,vKkr,FK0)
      CALL CF_VIS(Q1E,Q2E,Q3E,SI,SJ,SK,Volkr,SK,vEkr,FE0)
      FVKkr=FK0
      FVEkr=FE0
c      end if
c      write(*,*)('FV -DONE')

C***** Source terms: generation G and dissipation eps **********
       uim=0.5d0*(Qir(2)+Qc(2))
       vim=0.5d0*(Qir(3)+Qc(3))
       wim=0.5d0*(Qir(4)+Qc(4))

       ujm=0.5d0*(Qjr(2)+Qc(2))
       vjm=0.5d0*(Qjr(3)+Qc(3))
       wjm=0.5d0*(Qjr(4)+Qc(4))

       ukm=0.5d0*(Qkr(2)+Qc(2))
       vkm=0.5d0*(Qkr(3)+Qc(3))
       wkm=0.5d0*(Qkr(4)+Qc(4))

       uip=0.5d0*(Qc(2)+Qif(2))
       vip=0.5d0*(Qc(3)+Qif(3))
       wip=0.5d0*(Qc(4)+Qif(4))

       ujp=0.5d0*(Qc(2)+Qjf(2))
       vjp=0.5d0*(Qc(3)+Qjf(3))
       wjp=0.5d0*(Qc(4)+Qjf(4))

       ukp=0.5d0*(Qc(2)+Qkf(2))
       vkp=0.5d0*(Qc(3)+Qkf(3))
       wkp=0.5d0*(Qc(4)+Qkf(4))
c-----------------------------------
       ux=uip*SIXf - uim*SIXr +
     *    ujp*SJXf - ujm*SJXr +
     *    ukp*SKXf - ukm*SKXr
c-----------------------------------
       vx=vip*SIXf - vim*SIXr +
     *    vjp*SJXf - vjm*SJXr +
     *    vkp*SKXf - vkm*SKXr
c-----------------------------------
       wx=wip*SIXf - wim*SIXr +
     *    wjp*SJXf - wjm*SJXr +
     *    wkp*SKXf - wkm*SKXr
c-----------------------------------
       uy=uip*SIYf - uim*SIYr +
     *    ujp*SJYf - ujm*SJYr +
     *    ukp*SKYf - ukm*SKYr
c-----------------------------------
       vy=vip*SIYf - vim*SIYr +
     *    vjp*SJYf - vjm*SJYr +
     *    vkp*SKYf - vkm*SKYr
c-----------------------------------
       wy=wip*SIYf - wim*SIYr +
     *    wjp*SJYf - wjm*SJYr +
     *    wkp*SKYf - wkm*SKYr
c-----------------------------------
       uz=uip*SIZf - uim*SIZr +
     *    ujp*SJZf - ujm*SJZr +
     *    ukp*SKZf - ukm*SKZr
c-----------------------------------
       vz=vip*SIZf - vim*SIZr +
     *    vjp*SJZf - vjm*SJZr +
     *    vkp*SKZf - vkm*SKZr
c-----------------------------------
       wz=wip*SIZf - wim*SIZr +
     *    wjp*SJZf - wjm*SJZr +
     *    wkp*SKZf - wkm*SKZr
c-----------------------------------
       vt=Cmu*(TKc**2)/TEc  !! turbulent viscosity

C>     По умолчанию для GG и eps используются формулы:
       GG=vt*(2.d0*(ux*ux+vy*vy+wz*wz+uy*vx+uz*wx+vz*wy)+
     *        uy*uy+uz*uz+vx*vx+vz*vz+wx*wx+wy*wy)/(Volc**2)

C=================================================================================
C>     Для предотвращения роста GG в точках торможения потока введен ограничитель,
C>     согласно работе Durbin P. А. "Limiters and wall treatment in applied
C>     turbulence modeling", 2009.
C>     Эта модификация решающим образом устраняет выбросы на УХ для ПЛ-турбин при малых Fi.
C>     Smod - модуль тензора скоростей деформации (strain-tensor) = корень(2*Sij*Sij).
       Smod=DSQRT(2.d0*(ux*ux+vy*vy+wz*wz)+
     *            (uy+vx)**2+(uz+wx)**2+(vz+wy)**2)/Volc
       GG_k=DMIN1(GG,2.d0*TKc*Smod/DSQRT(3.d0))
C=================================================================================

       eps=TEc
       SrcK=eps/TKc
       SrcE=Ceps2*eps/TKc
       HK=GG_k            -SrcK*TKc
       HE=Ceps1*eps*GG/TKc-SrcE*TEc+Ceps3*GG*GG/TKc  !! Для стандартной k-e модели Ceps3=0.
       VolEff=Volc                                   !! Таким образом, k-e солвер универсальный,
                                                     !! пригодный как для стандартной k-e модели,
                                                     !! так и для Kim-Chen модели турбулентности.
c===========================================================================
C>     Если рядом твердая стенка, то SrcK, GG и eps для k-уравнения, a также
C>     VolEff, HE и SrcE для e-уравнения вычисляются другим образом:

       isIwall=0
       isJwall=0
       isKwall=0
       SourceType=1

C====== I=3 BOUNDARY ===============================================
       if((i.EQ.3).AND.
     *   ((IZNAK.EQ.1).OR.
     *     ((BLOCK_SYMBOL.EQ.'a').AND.(j.GE.INTPAR(15))))) then
         CALL Find_Ge_wall(SourceType,Qc,SIXr,SIYr,SIZr,
     *            YPI(1,j,k),TKc,Cmu,Ckar,CE,Reyn,GG,eps1)
         CALL Find_eps_nw(TKc,YPI(1,j,k),Cmu,Ckar,eps_nw)
         isIwall=1
       endif

C====== I=K13 BOUNDARY =============================================
       if((i.eq.K13).AND.
     *    (((BLOCK_SYMBOL.EQ.'s').AND.(j.GE.INTPAR(15))).OR.
     *     ((nz_begin.gt.0).and.(NDOMN.eq.nz_begin+1)))) then
         CALL Find_Ge_wall(SourceType,Qc,SIXf,SIYf,SIZf,
     *            YPI(2,j,k),TKc,Cmu,Ckar,CE,Reyn,GG,eps1)
         CALL Find_eps_nw(TKc,YPI(2,j,k),Cmu,Ckar,eps_nw)
         isIwall=1
       endif

C====== J=3 BOUNDARY ===============================================
       if(j.eq.3) then
         Krot=0
         if(BLOCK_SYMBOL.eq.'k') then
           Xw=0.5d0*(X(I,2,K)+X(I,3,K))  !!
           Yw=0.5d0*(Y(I,2,K)+Y(I,3,K))  !! Координаты на стенке
           Zw=0.5d0*(Z(I,2,K)+Z(I,3,K))  !!
           CALL STOB(1,Xw,Yw,Zw,REALPAR,IP)
           if((IP.eq.0).or.
     *       ((TurbineType.eq.'k').or.(TurbineType.eq.'K'))) Krot=1
         endif
         if((BLOCK_SYMBOL.eq.'z').and.(NDOMN.eq.nz_begin)) then
C          В блоке z01 стенка j=3 - вращается.
           Krot=1
         endif
C        Krot=0 - стенка неподвижна относительно нашей системы координат.
C        Krot=1 - стенка вращается относительно нашей системы координат.
         QcM(1)=Qc(1)
         QcM(2)=Qc(2)-Krot*OM*Y(i,j,k)
         QcM(3)=Qc(3)+Krot*OM*X(i,j,k)
         QcM(4)=Qc(4)
         CALL Find_Ge_wall(SourceType,QcM,SJXr,SJYr,SJZr,
     *            YPJ(1,i,k),TKc,Cmu,Ckar,CE,Reyn,GG,eps1)
         CALL Find_eps_nw(TKc,YPJ(1,i,k),Cmu,Ckar,eps_nw)
         isJwall=1
       endif

C====== J=K23 BOUNDARY =============================================
       XX=0.5d0*(X(I,J,K)+X(I,J+1,K))
       YY=0.5d0*(Y(I,J,K)+Y(I,J+1,K))
       RR=DSQRT(XX**2+YY**2)
       if((j.eq.K23).and.
     *   ((BLOCK_SYMBOL.ne.'k').or.(RR.ge.Rsrez))) then
         Krot=0
         if(BLOCK_SYMBOL.eq.'k') then
           Xw=0.5d0*(X(I,K23,K)+X(I,K22,K))  !!
           Yw=0.5d0*(Y(I,K23,K)+Y(I,K22,K))  !! Координаты на стенке
           Zw=0.5d0*(Z(I,K23,K)+Z(I,K22,K))  !!
           CALL STOB(2,Xw,Yw,Zw,REALPAR,IP)
           if(IP.eq.0) Krot=1
         endif
C        Krot=0 - стенка неподвижна относительно нашей системы координат.
C        Krot=1 - стенка вращается относительно нашей системы координат.
         QcM(1)=Qc(1)
         QcM(2)=Qc(2)-Krot*OM*Y(i,j,k)
         QcM(3)=Qc(3)+Krot*OM*X(i,j,k)
         QcM(4)=Qc(4)
         CALL Find_Ge_wall(SourceType,QcM,SJXf,SJYf,SJZf,
     *            YPJ(2,i,k),TKc,Cmu,Ckar,CE,Reyn,GG,eps1)
         CALL Find_eps_nw(TKc,YPJ(2,i,k),Cmu,Ckar,eps_nw)
         isJwall=1
       endif

C====== K=3 BOUNDARY ===============================================
       if((k.eq.3).and.(KRT2(i,j,1).eq.1)) then
         CALL Find_Ge_wall(SourceType,Qc,SKXr,SKYr,SKZr,
     *            YPK(1,i,j),TKc,Cmu,Ckar,CE,Reyn,GG,eps1)
         CALL Find_eps_nw(TKc,YPK(1,i,j),Cmu,Ckar,eps_nw)
         isKwall=1
       endif

C====== K=K33 BOUNDARY =============================================
       if((k.eq.K33).and.(KRT1(i,j,1).eq.1)) then
         CALL Find_Ge_wall(SourceType,Qc,SKXf,SKYf,SKZf,
     *            YPK(2,i,j),TKc,Cmu,Ckar,CE,Reyn,GG,eps1)
         CALL Find_eps_nw(TKc,YPK(2,i,j),Cmu,Ckar,eps_nw)
         isKwall=1
       endif

C====== РАСЧЕТ HK,HE,SrcK,SrcE вблизи стенки =======================
       if((isIwall.eq.1).or.(isJwall.eq.1).or.(isKwall.eq.1)) then
         SrcK=eps1/TKc
         HK=GG-SrcK*TKc

         SrcE=0.d0
         HE=(eps_nw-TEc)/TAU
         VolEff=VeryLargeNumber
       endif
c===========================================================================

C      Расчет eps перед входной кромкой и сразу за выходной кромкой лопасти
C      по формуле eps_nw, как на твердой стенке.
       isKcorner=0
C====== K=3 BOUNDARY, BEFORE AND BEHIND BLADE ==============================
       if((k.eq.3).and.(KRT2(i,j,1).ne.1)) then
         if((KRT2(i+1,j,1).eq.1).or.
     *      (KRT2(i-1,j,1).eq.1)) then
           CALL Find_eps_nw(TKc,YPK(1,i,j),Cmu,Ckar,eps_nw)
           isKcorner=1
         endif
       endif
C====== K=K33 BOUNDARY, BEFORE AND BEHIND BLADE ============================
       if((k.eq.K33).and.(KRT1(i,j,1).ne.1)) then
         if((KRT1(i+1,j,1).eq.1).or.
     *      (KRT1(i-1,j,1).eq.1)) then
           CALL Find_eps_nw(TKc,YPK(2,i,j),Cmu,Ckar,eps_nw)
           isKcorner=1
         endif
       endif
       if(isKcorner.eq.1) then
         SrcE=0.d0
         HE=(eps_nw-TEc)/TAU
         VolEff=VeryLargeNumber
       endif

C*** RHSK и RHSE ***********************************************************
       RHSK(i,j,k)= -(FNKif+FVKif-FNKir     -FVKir+
     *         FNKjf+FVKjf-FNKjr(i)  -FVKjr(i)+
     *         FNKkf+FVKkf-FNKkr-FVKkr)+ ! FNKkr(i,j)-FVKkr(i,j)
     *         HK*Volc
       RHSE(i,j,k)= -(FNEif+FVEif-FNEir     -FVEir+
     *         FNEjf+FVEjf-FNEjr(i)  -FVEjr(i)+
     *         FNEkf+FVEkf-FNEkr-FVEkr)+ ! FNEkr(i,j)-FVEkr(i,j)
     *         HE*VolEff

C*** Evaluation of Residual ******************
       ResK=DABS(RHSK(i,j,k))/Volc
       ResE=DABS(RHSE(i,j,k))/VolEff
       if(ResK.GT.ResKMax) ResKMax=ResK
       if(ResE.GT.ResEMax) ResEMax=ResE

       if(ResK.LE.1.e-16) then
         ResMK(i,j,k)=-16.d0
       else
         ResMK(i,j,k)=DLOG(ResK)/DLOG(10.d0)
       end if

       if(ResE.LE.1.e-16) then
         ResME(i,j,k)=-16.d0
       else
         ResME(i,j,k)=DLOG(ResE)/DLOG(10.d0)
       end if

       SumDivK=SumDivK+ResK*ResK*Volc
       SumDivE=SumDivE+ResE*ResE*Volc
       SumVol =SumVol+Volc
c       write(*,*)('Res -DONE')

C*** C-scalars *******************************
       CirK=BirK-Apir
       CjrK=BjrK-Apjr
       CkrK=BkrK-Apkr
       CifK=BifK+Amif
       CjfK=BjfK+Amjf
       CkfK=BkfK+Amkf

       CirE=BirE-Apir
       CjrE=BjrE-Apjr
       CkrE=BkrE-Apkr
       CifE=BifE+Amif
       CjfE=BjfE+Amjf
       CkfE=BkfE+Amkf

C*** D-scalars *******************************
       DK=  Volc*(1.d0/TAU+SrcK)-(CirK+CjrK+CkrK+CifK+CjfK+CkfK)
       DE=VolEff*(1.d0/TAU+SrcE)-(CirE+CjrE+CkrE+CifE+CjfE+CkfE)
c       write(*,*) DK,DE,TAU
c       if(DABS(DK).LT.1.e-16) PAUSE "DK is small"
c       if(DABS(DE).LT.1.e-16) PAUSE "DE is small"

C*** EXCHANGE *******************
       FNKir     =FNKif
       FVKir     =FVKif
       FNKjr(i)  =FNKjf
       FVKjr(i)  =FVKjf
!! uses in 1-proc version without OpenMP
!       FNKkr(i,j)=FNKkf
!       FVKkr(i,j)=FVKkf
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       FNEir     =FNEif
       FVEir     =FVEif
       FNEjr(i)  =FNEjf
       FVEjr(i)  =FVEjf
!! uses in 1-proc version without OpenMP
!       FNEkr(i,j)=FNEkf
!       FVEkr(i,j)=FVEkf
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

C*** REMEMBERING ****************
       DKM(i,j,k)=DK
       DEM(i,j,k)=DE

       CirKM(i,j,k)=CirK
       CjrKM(i,j,k)=CjrK
       CkrKM(i,j,k)=CkrK
       CirEM(i,j,k)=CirE
       CjrEM(i,j,k)=CjrE
       CkrEM(i,j,k)=CkrE

       CifKM(i,j,k)=CifK
       CjfKM(i,j,k)=CjfK
       CkfKM(i,j,k)=CkfK
       CifEM(i,j,k)=CifE
       CjfEM(i,j,k)=CjfE
       CkfEM(i,j,k)=CkfE
560   CONTINUE

C*** THE END of UP-RUNCOUNT ************************************
C  < Закончили бегущий счет вверх. Конец первого полушага. >
c      write(*,*)(' UP - finished')

C***** THE BEGINNING OF UP-RUNCOUNT ******************************
C*** New PSYmK and PSYmE *********************
      DO 660 SumIJK=9,K13+K23+K33
!$omp do
      DO 660 SumJK=max(6,SumIJK-K13),min(K23+K33,SumIJK-3)
      DO 660 K=max(3,SumJK-K23),min(K33,SumJK-3)
         J=SumJK-K
         I=SumIJK-K-J
       PSYmK(i,j,k)=(RHSK(i,j,k)-CirKM(i,j,k)*PSYmK(i-1,j,k)-
     *                    CjrKM(i,j,k)*PSYmK(i,j-1,k)-
     *                    CkrKM(i,j,k)*PSYmK(i,j,k-1))/DKM(i,j,k)
       PSYmE(i,j,k)=(RHSE(i,j,k)-CirEM(i,j,k)*PSYmE(i-1,j,k)-
     *                    CjrEM(i,j,k)*PSYmE(i,j-1,k)-
     *                    CkrEM(i,j,k)*PSYmE(i,j,k-1))/DEM(i,j,k)
660   CONTINUE
C*** THE END OF UP-RUNCOUNT **********************************
c      write(*,*)(' UP - finished')

!$omp do
      DO 590 j=3,K23
      DO 590 i=3,K13
        dPsiK(i,j,K32)=0.d0
590     dPsiE(i,j,K32)=0.d0
!$omp do
      DO 592 k=3,K33
      DO 592 j=3,K23
        dPsiK(K12,j,k)=0.d0
592     dPsiE(K12,j,k)=0.d0
!$omp do
      DO 594 k=3,K33
      DO 594 i=3,K13
        dPsiK(i,K22,k)=0.d0
594     dPsiE(i,K22,k)=0.d0

C*** THE BEGINING OF DOWN-RUNCOUNT *****************************
      DO 680 SumIJK=9,K13+K23+K33
!$omp do
      DO 680 SumJK=max(6,SumIJK-K13),min(K23+K33,SumIJK-3)
      DO 680 Knn=max(3,SumJK-K23),min(K33,SumJK-3)
         Jnn=SumJK-Knn
         Inn=SumIJK-Knn-Jnn
        k=K3-Knn
        j=K2-Jnn
        i=K1-Inn
        dPsiK(i,j,k)=PSYmK(i,j,k) -
     *                  (CifKM(i,j,k)*dPsiK(i+1,j,k)+
     *                   CjfKM(i,j,k)*dPsiK(i,j+1,k)+
     *                   CkfKM(i,j,k)*dPsiK(i,j,k+1))/DKM(i,j,k)
        dPsiE(i,j,k)=PSYmE(i,j,k) -
     *                  (CifEM(i,j,k)*dPsiE(i+1,j,k)+
     *                   CjfEM(i,j,k)*dPsiE(i,j+1,k)+
     *                   CkfEM(i,j,k)*dPsiE(i,j,k+1))/DEM(i,j,k)
680   CONTINUE
C*** THE END OF DOWN-RUNCOUNT **********************************
c      write(*,*)(' DOWN - finished')

!$omp do
      DO 800 k=3,K33
      DO 800 j=3,K23
      DO 800 i=3,K13
        TK(i,j,k)=TK(i,j,k)+dPsiK(i,j,k)
        TE(i,j,k)=TE(i,j,k)+dPsiE(i,j,k)
800   CONTINUE

C===============================================================
C     Коррекция полей k и eps.
C     Для отключения коррекции необходимо раскомментировать
C     следующую строку:

c      GOTO 900
C===============================================================
      NKnegCorr=0
      NEnegCorr=0
      NEcutCorr=0
      KSDV(1,1)= -1
      KSDV(1,2)=  0
      KSDV(1,3)=  0
      KSDV(2,1)=  1
      KSDV(2,2)=  0
      KSDV(2,3)=  0
      KSDV(3,1)=  0
      KSDV(3,2)= -1
      KSDV(3,3)=  0
      KSDV(4,1)=  0
      KSDV(4,2)=  1
      KSDV(4,3)=  0
      KSDV(5,1)=  0
      KSDV(5,2)=  0
      KSDV(5,3)= -1
      KSDV(6,1)=  0
      KSDV(6,2)=  0
      KSDV(6,3)=  1
!$omp do
      DO 840 k=3,K33
      DO 840 j=3,K23
      DO 840 i=3,K13
        if(TK(i,j,k).LT.1.e-16) then
C          print *, "TK=",TK(i,j,k),"   i,j,k,=",i,j,k
C          print *, 'Correcting TK.'
CC         Берем среднее среди ближайших положительных.
          NKnegCorr=NKnegCorr+1
          TKsum=0.d0
          MP=0
          DO 810 m=1,6
            is=i+KSDV(m,1)
            js=j+KSDV(m,2)
            ks=k+KSDV(m,3)
            if((TK(is,js,ks).gt.1.e-16).and.
     *         (js.ge.3).and.(js.le.K23).and.
     *         (ks.ge.3).and.(ks.le.K33)) then
              TKsum=TKsum+TK(is,js,ks)
              MP=MP+1
            endif
810       CONTINUE
          TK(i,j,k)=TKsum/MP
        endif

C===============================================================
       if(TE(i,j,k).LT.1.e-16) then
C          print *, "TE=",TE(i,j,k),"   i,j,k,=",i,j,k
C          print *, 'Correcting TE.'
          NEnegCorr=NEnegCorr+1
          TELoc(1)=TE(i-1,j,k)
          TELoc(2)=TE(i+1,j,k)
          TELoc(3)=TE(i,j-1,k)
          TELoc(4)=TE(i,j+1,k)
          TELoc(5)=TE(i,j,k-1)
          TELoc(6)=TE(i,j,k+1)
          TEmin=1.e+20
C         Берем минимум среди ближайших.
          DO 820 m=1,6
            if((TELoc(m).lt.TEmin).and.(TELoc(m).gt.1.e-16)) then
              TEmin=TELoc(m)
            endif
820       CONTINUE
          TE(i,j,k)=TEmin
        endif
840   CONTINUE

C===============================================================
!$omp do
      DO 870 k=3,K33
      DO 870 j=3,K23
      DO 870 i=3,K13
        TEmedium=(TE(i-1,j,k)+TE(i,j-1,k)+TE(i,j,k-1)+
     *            TE(i+1,j,k)+TE(i,j+1,k)+TE(i,j,k+1))/6.d0
        TEcut=TEmedium/5.d0
        if(TE(i,j,k).LT.TEcut) then
          vtc = Cmu*(TK(i,j,k)**2)/TE(i,j,k)
          vtir= Cmu*(TK(i-1,j,k)**2)/TE(i-1,j,k)
          vtif= Cmu*(TK(i+1,j,k)**2)/TE(i+1,j,k)
          vtjr= Cmu*(TK(i,j-1,k)**2)/TE(i,j-1,k)
          vtjf= Cmu*(TK(i,j+1,k)**2)/TE(i,j+1,k)
          vtkr= Cmu*(TK(i,j,k-1)**2)/TE(i,j,k-1)
          vtkf= Cmu*(TK(i,j,k+1)**2)/TE(i,j,k+1)
          vtmax=DMAX1(vtir,vtif,vtjr,vtjf,vtkr,vtkf)
          if(vtc.gt.vtmax) then
C            print 872,TE(i,j,k),TEcut,i,j,k
C872         FORMAT('TE=',E11.4,'   TEcut=',E11.4,
C     *             '  i,j,k,=',I4,I4,I4)
C            print *, '=====>>> Corrrecting.'
            NEcutCorr=NEcutCorr+1
            TE(i,j,k)=TEcut
          endif
        endif
870   CONTINUE

!$omp end parallel
      if(ReturnFlag) RETURN

C==== Выдача сообщения на экран ================================
      if(((NKnegCorr+NEnegCorr+NEcutCorr).gt.0).AND.IsPrint) then
        print 890,NKnegCorr,NEnegCorr,NEcutCorr
890     FORMAT(12X,'CORRECTION [K-neg:',I4,
     *         ';  E-neg:',I4,';  E-cut:',I4,']')
      endif
C==== Коррекция полей k и eps закончена ========================

900   CONTINUE
      RETURN
      END

      SUBROUTINE CF_IN(Q1,Q2,qm1,qm2,Sx,Sy,Sz,Flux)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION Q1(4),Q2(4)

C     Процедура для вычисления невязкого потока k или eps через грань m+1/2.
C     Q1,Q2 - вектора (p,u,v,w) в точках m,m+1,
C     qm1,qm2 - значения k или eps в точках m,m+1.
C     Используется схема первого порядка.

      A=0.5d0*((Q1(2)+Q2(2))*Sx+(Q1(3)+Q2(3))*Sy+(Q1(4)+Q2(4))*Sz)

      RS1=qm1*(Q1(2)*Sx+Q1(3)*Sy+Q1(4)*Sz)
      RS2=qm2*(Q2(2)*Sx+Q2(3)*Sy+Q2(4)*Sz)

      Flux=0.5d0*(RS1+RS2-DABS(A)*(qm2-qm1))
      RETURN
      END



c8888888888888888888888888888888888888888888888888888888888888888888888
c8888888888888888888888888888888888888888888888888888888888888888888888

      SUBROUTINE CF_VIS(QE1,QE2,QE3,SI,SJ,SK,Vol,Sm,vK,Fvis)
      IMPLICIT REAL*8 (A-H,O-Z)
      DIMENSION SI(3),SJ(3),SK(3),Sm(3)

C     Процедура для вычисления вязкого потока через грань.
C     t={k или eps}
      t_x=(QE1*SI(1)+QE2*SJ(1)+QE3*SK(1))/Vol
      t_y=(QE1*SI(2)+QE2*SJ(2)+QE3*SK(2))/Vol
      t_z=(QE1*SI(3)+QE2*SJ(3)+QE3*SK(3))/Vol
      Fvis=-vK*(t_x*Sm(1)+t_y*Sm(2)+t_z*Sm(3))
      RETURN
      END


c8888888888888888888888888888888888888888888888888888888888888888888888
c8888888888888888888888888888888888888888888888888888888888888888888888

      SUBROUTINE Find_Ge_wall(SourceType,Q1,Sx,Sy,Sz,yp,TK,
     *                                   Cmu,Ckar,CE,Reyn,G,eps)
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*8 nx,ny,nz,nu_wall
      INTEGER SourceType
      DIMENSION Q1(4)

C     Процедура нахождения члена генерации G и диссипации eps, входящих в источник.
C     Предполагается, что yp находится в логарифмическом слое (30< y+ <300).
C     Способ вычисления: SOURCE1 или SOURCE3 (см. описание солвера STREAM 4.5.2),
C     определяется параметром SourceType (SourceType= 1 или 3).

      SS=DSQRT(Sx**2+Sy**2+Sz**2)
      if(SS.gt.1.e-20) then
        nx=Sx/SS
        ny=Sy/SS
        nz=Sz/SS
      else
        nx=0.d0
        ny=0.d0
        nz=0.d0
      endif
      u=Q1(2)
      v=Q1(3)
      w=Q1(4)
      Un=u*nx+v*ny+w*nz
      Utx=u-Un*nx
      Uty=v-Un*ny
      Utz=w-Un*nz

      CM14K12=(Cmu**0.25d0)*DSQRT(TK)
      y_plus=CM14K12*yp*Reyn
C     Логарифмический закон для вычисления tau_w:
c      nu_wall=(1.d0/Reyn)*Ckar*y_plus/DLOG(CE*y_plus)
C     Вязкий или логарифмический закон для tau_w:

C     Чтобы в процессе установления не происходило деление
C     на очень маленькое число (при y_plus близком к 0.112),
C     ограничим y_plus, через который вычисляется nu_wall.
C     Это не влияет на точность расчета, так как все равно
C     при вычислении nu_wall будет взят DMAX1.
      y_plus1=DMAX1(1.d0,y_plus)
      nu_wall=(1.d0/Reyn)*DMAX1(1.d0,Ckar*y_plus1/DLOG(CE*y_plus1))

      G=(nu_wall**2)*(Utx**2+Uty**2+Utz**2)/(Ckar*CM14K12*(yp**3))
      eps=(CM14K12**3)/(Ckar*yp)
      if(SourceType.eq.3) then
        G  =G  *DLOG(CE*y_plus)
        eps=eps*DLOG(CE*y_plus)
      endif
      RETURN
      END


c8888888888888888888888888888888888888888888888888888888888888888888888
c8888888888888888888888888888888888888888888888888888888888888888888888

      SUBROUTINE Find_eps_nw(TK,yp,Cmu,Ckar,eps_nw)
      IMPLICIT REAL*8 (A-H,O-Z)
C     Процедура нахождения eps_nw.
C     Предполагается, что yp находится в логарифмическом слое (30< y+ <300).
      eps_nw=(Cmu**0.75d0)*(TK**1.5d0)/(Ckar*yp)
      RETURN
      END

c8888888888888888888888888888888888888888888888888888888888888888888888
c8888888888888888888888888888888888888888888888888888888888888888888888
					</code></pre>
				</section>
				<section>
					<h3 style="text-align: left">Java Code Example from 2018</h3>
					<pre><code class="language-java">
package ru.yandex.assay.accuracy.evaluation;

import org.jetbrains.annotations.Nullable;
import ru.yandex.assay.accuracy.model.AttributeChange;
import ru.yandex.assay.accuracy.model.CompanyChange;
import ru.yandex.assay.altay.tds.TDSLangString;
import ru.yandex.assay.altay.tds.model.AbstractTDSCompany.PublishingStatus;
import ru.yandex.assay.altay.tds.model.AbstractTDSName.Type;
import ru.yandex.assay.altay.tds.model.TDSAddress;
import ru.yandex.assay.altay.tds.model.TDSAddress.TDSPosition;
import ru.yandex.assay.altay.tds.model.TDSCompany;
import ru.yandex.assay.altay.tds.model.TDSCompany.TDSCompanyRubric;
import ru.yandex.assay.altay.tds.model.TDSName;
import ru.yandex.assay.altay.tds.model.TDSPhone;
import ru.yandex.assay.altay.tds.model.TDSUrl;
import ru.yandex.assay.altay.tds.model.TDSWorkInterval;
import ru.yandex.assay.altay.unification.UnifierApi;
import ru.yandex.qe.util.enums.LangIso639;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.function.Function;
import java.util.stream.Collectors;

public class CompanyChangeToTdsCompany {
	public CompanyChangeToTdsCompany(@Nullable UnifierApi unifier) {
		this.unifier = unifier;
	}

	private final UnifierApi unifier;

	public TDSCompany convertActual(CompanyChange companyChange, LangIso639 lang) {
		return convert(companyChange, lang, AttributeChange::before);
	}

	public TDSCompany convertExpected(CompanyChange companyChange, LangIso639 lang) {
		return convert(companyChange, lang, AttributeChange::after);
	}

	private TDSCompany convert(CompanyChange companyChange, LangIso639 lang,
			Function<AttributeChange, String> function) {
		PublishingStatus ps = PublishingStatus.valueOf(function.apply(
				companyChange.publishingStatusChange()));

		List<TDSName> names = Arrays.asList(
				TDSName.of(TDSLangString.of(lang, function.apply(companyChange.nameChange())), Type.MAIN),
				TDSName.of(TDSLangString.of(lang, function.apply(companyChange.shortNameChange())), Type.SHORT)
		);
		double lat = 0.0;
		double lon = 0.0;
		String latlon = function.apply(companyChange.coordinateChange());
		if (!latlon.isEmpty()) {
			lat = Double.parseDouble(latlon.split(",")[0].split(" ")[0]);
			lon = Double.parseDouble(latlon.split(",")[1].split(" ")[0]);
		}

		TDSAddress tdsAddress = TDSAddress.empty()
				.withFormatted(TDSLangString.of(lang, function.apply(companyChange.addressChange())))
				.withPos(TDSPosition.of(lon, lat));

		List<TDSPhone> phones = Arrays.stream(function.apply(companyChange.phoneChange()).split(";"))
				.filter(x -> !x.isEmpty())
				.map(x -> TDSPhone.builder().number(x).formatted(x).build())
				.collect(Collectors.toList());

		List<TDSCompanyRubric> rubrics = Arrays.stream(function.apply(companyChange.rubricChange()).split(";"))
				.filter(x -> !x.isEmpty())
				.map(x -> TDSCompanyRubric.builder().id(Long.parseLong(x)).build())
				.collect(Collectors.toList());

		List<TDSUrl> urls = new ArrayList<>();
		Arrays.stream(function.apply(companyChange.urlChange()).split(";"))
				.filter(x -> !x.isEmpty())
				.map(x -> TDSUrl.of(x, TDSUrl.Type.MAIN))
				.forEach(urls::add);
		Arrays.stream(function.apply(companyChange.alternativeUrlChange()).split(";"))
				.filter(x -> !x.isEmpty())
				.map(x -> TDSUrl.of(x, TDSUrl.Type.ALTERNATIVE))
				.forEach(urls::add);
		Arrays.stream(function.apply(companyChange.socialUrlChange()).split(";"))
				.filter(x -> !x.isEmpty())
				.map(x -> TDSUrl.of(x, TDSUrl.Type.SOCIAL))
				.forEach(urls::add);
		List<TDSWorkInterval> workIntervals = Collections.emptyList();
		if (unifier != null) {
			workIntervals = unifier.unifyWorkingTime(function.apply(companyChange.workingTimeChange()));
		}

		return TDSCompany.empty()
				.withPublishingStatus(ps)
				.withNames(names)
				.withAddress(tdsAddress)
				.withPhones(phones)
				.withRubrics(rubrics)
				.withUrls(urls)
				.withWorkIntervals(workIntervals);
	}
}
					</code></pre>
				</section>
			</section>
			<section>
				<section>
					<h3 style="text-align: left">Design Patterns in Open Source Projects</h3>
					<div class="fragment">
						<div class="typesetting">
							<p style="text-align: left">
								Exploring how established open source projects implement
								design patterns offers insights into practical applications and
								benefits.</p>
							<ul>
								<li><strong class="important">Spring Framework (Java):</strong>
									Employs the Singleton pattern extensively for bean management,
									ensuring efficient, consistent object access throughout the application
									lifecycle.</li>
								<li><strong class="important">React (JavaScript):</strong>
									Uses the Observer pattern to manage state and props changes,
									enabling dynamic UI updates in response to data modifications.</li>
							</ul>
						</div>
					</div>
				</section>
				<section>
					<h3 style="text-align: left">
						Addressing Anti-Patterns: Lessons from Established Companies</h3>
					<div class="fragment">
						<div class="typesetting">
						<p style="text-align: left">
							Even well-established companies encounter and overcome antipatterns,
							demonstrating resilience and the capacity for continuous improvement.</p>
						<ul>
							<li><strong class="important">Netflix's Transition:</strong> Originally faced challenges with the Monolithic Architecture anti-pattern. By adopting a microservices architecture, Netflix enhanced scalability and deployment speeds, showcasing the importance of architectural evolution.</li>
							<li><strong class="important">Microsoft's GitHub Acquisition:</strong> Demonstrated a strategic move away from the Vendor Lock-in anti-pattern by embracing open source projects and community engagement, broadening their technology stack and innovation potential.</li>
						</ul>
						<p style="text-align: left">
							These examples underline the significance of recognizing,
							addressing, and learning from anti-patterns to foster growth and
							innovation.</p>
						</div>
					</div>
				</section>
				<section>
				  <h3 style="text-align: left">Summary</h3>
					<div class="fragment">
						<div class="typesetting">
						  <ul>
							<li>Patterns as blueprints for robust design,
								categorized into Creational,
								Structural, Behavioral, and Concurrency</li>
							<li>Anti-Patterns identified as common pitfalls
								with strategies to refactor</li>
							<li>Case studies in open-source and enterprise-level applications
								underline their real-world significance</li>
						  </ul>
						</div>
					</div>
				</section>
			</section>
		</div>
	</div>
		<script src="../dist/reveal.js"></script>
		<script src="../plugin/notes/notes.js"></script>
		<script src="../plugin/markdown/markdown.js"></script>
		<script src="../plugin/highlight/highlight.js"></script>
		<script src="../plugin/math/math.js"></script>
		<script src="../scripts/utils.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,
				// The "normal" size of the presentation, aspect ratio will
				// be preserved when the presentation is scaled to fit different
				// resolutions. Can be specified using percentage units.
				width: '100%',
				height: '100%',
				// Factor of the display size that should remain empty around the content
				margin: 0.08,

				// Bounds for smallest/largest possible scale to apply to content
				minScale: 0.2,
				maxScale: 2.0,
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX ]
			});

			Reveal.addEventListener('fragmentshown', function (event) {
				if (lettersAnimate) {
					[...event.fragment.getElementsByClassName('typesetting')].forEach(element => {
						playAnimation(element);
					});
				}
			});

		</script>
    </body>
</html>
